---
title: SS那些事
tags: []
categories: []
keywords: []
date: 2019-07-28 15:20:37
---
> 怕里面有什么？有怒。
> --《让子弹飞》
<!--more-->
# 什么是FQ？
故事要从很久以前说起，那个时候大家是这样上外网的：用户的请求直接发给服务提供方的服务器，而服务器直接把响应返回给用户。

{% asset_img rq1.png %}

后来，墙出现了。所有经过外网的请求和响应都会经过GFW，GFW把所有不想让用户看到的请求和响应过滤掉。于是当用户的访问出发GFW的过滤规则的时候，浏览器就会出现 **connection reset** .

{% asset_img rq2.png %}

其实GFW的内部结构一直是个迷，我们只能通过各种尝试和访问结果进行逆推，猜测墙的结构，目前比较公认的结构是这样的。

{% asset_img rq3.jpg %}

好了，现在我们无法正常的使用互联网了，GFW会把直连的请求拦截掉。……等一下，如果请求不是直连的呢？

>世界上本没有梯子，墙高了，也就有了梯子。有了梯子，也才有了翻墙。
>——鲁迅
>{% asset_img 1.jpg %}

我们有了一个简单可行的方案，使用"梯子"FQ——也就是使用代理。

通过使用代理，用户的请求不再直接访问服务提供方的服务器，而是访问搭建的代理服务器，同时用户和代理服务器之间的通信经过加密，GFW不能看到内容不能知道用户的最终访问地址，是不是就可以自由上网了？
{% asset_img rq5.png %}

答案是否定的。因为GFW有个大杀器，这个大杀器的名字叫做——特征分析。
很多VPN或者代理协议都需要建立连接并进行通信，而建立连接和通信是需要协议做支持的，而"协议"就意味着固定的模式，这也让GFW有了分析数据包的可能。

# 插播一条消息——socks协议是啥？
>SOCKS是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。SOCKS是"SOCKetS"的缩写。
>当防火墙后的客户端要访问外部的服务器时，就跟SOCKS代理服务器连接。这个代理服务器控制客户端访问外网的资格，允许的话，就将客户端的请求发往外部的服务器。
>-- https://zh.wikipedia.org/wiki/SOCKS

结论：
+ socks协议有客户端和服务端。在两者建立连接后，服务端解析客户端的数据包能够得知客户端需要访问的地址，并代替它进行请求，之后传回响应。
+ socks协议工作在TCP/IP层，对于高层的协议无法干预，比如如果通过socks协议代理http请求，那么报文中就都是http请求的明文数据。所以存在socks over TLS的解决方案。

# 说回FQ——SSH tunnel是啥？
ssh不仅是一个登录远程机器的工具，也提供了非常强大的动态代理功能。

>{% asset_img d.png %}
>指定本地“动态”应用程序级端口转发。这通过分配套接字来侦听本地端口，可选地绑定到指定的bind_address。 只要与此端口建立连接，就会通过安全通道转发连接，然后使用应用程序协议确定从远程计算机连接到的位置。 目前支持SOCKS4和SOCKS5协议，ssh将充当SOCKS服务器。 只有root才能转发特权端口。 还可以在配置文件中指定动态端口转发。

通过一行代码就可以在本地建立一个监听本地端口的socks代理
``
ssh -D 7001 username@remote-host
``
然后就可以在本地配置该socks代理了，
{% asset_img proxy.png %}
所以只要有一个外网的VPS，在你的机器上有一个ssh的客户端，就可以以极低的成本建立一个梯子。这就是ssh tunnel。以ssh隧道加密和socks协议为基础的链路。
{% asset_img rq6.png %}

但是由于ssh建立连接和通信过程（http）中的特征十分明显，这个方法很容易就被GFW模式识别了。

# 进入正题——SS怎么做到的?
>从校长最近的论文上上看，GFW 最近弄的是先检测首部特征判断 SSL 和 SSH，然后统计包长度和方向，用实现训练好的模型去判断承载的流量是否为 HTTP。如果你用 SSH 翻墙，或者你的操作行为发的数据包过于接近 HTTP，就会被 reset。反过来，如果你想用 SSH 翻墙，只要在用来翻墙的那个 ssh 连接里做些别的操作（比如反复 tail 一个长文件，这样会不停的输出；或者用管道不停的往 ssh 里写命令，这样会不停的输入），就可以让这个模型失效，从而不会被判定为翻墙。
> -- clowwindy

说白了就是使用ssh tunnel的模式，但是不要让自己的数据包拥有ssh tunnel传输http时那样明显的特征。

easy。只要脱离ssh建立连接和通信协议，使用公开的加密协议就好了。这样的话对于每个包，除了TCP/IP的包头，包体都是密文的字节流，没有特征码供GFW识别而且也无法被解密。

{% asset_img rq7.png %}

SS是一个非常简单，但是非常有效的工具。在最开始ss这个工程只有两个主要文件，local.py 和 server.py分别运行在本地和外网服务器。[非官方的备份](https://github.com/YvesChan/shadowsocks)。通过阅读这份简化的代码，我们可以对ss的原理有非常清晰的认识。

# SS的弱点
[协议弱点 --> OTA --> AEAD](https://blessing.studio/why-do-shadowsocks-deprecate-ota/)


#reference
+ http://vc2tea.com/whats-shadowsocks/
+ https://segmentfault.com/a/1190000011485579
+ https://zh.wikipedia.org/wiki/SOCKS